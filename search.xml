<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>静态代理和动态代理详解</title>
      <link href="/2023/08/04/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/08/04/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代理"><a href="#1-代理" class="headerlink" title="1 代理"></a>1 代理</h1><ul><li>生活中的代理：比如我们生活中比较熟悉的代购、中介、商家等都是属于代理</li></ul><h1 id="2-什么是代理模式"><a href="#2-什么是代理模式" class="headerlink" title="2 什么是代理模式"></a>2 什么是代理模式</h1><p>代理模式是指：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。换句话说，使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑。</p><p>客户类真正想要访问的对象是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。</p><p>比如：有A、B、C三个类，A原来可以调用C类的方法，现在因为某种原因C类不允许A类调用其方法，但B类可以调用C类的方法。A类通过B类调用C类的方法。这里B是C的代理。</p><h1 id="3-代理模式的作用"><a href="#3-代理模式的作用" class="headerlink" title="3 代理模式的作用"></a>3 代理模式的作用</h1><p>功能增强: 在原有的功能上，增加了额外的功能，新增加的功能，叫做功能增强，</p><p>控制访问：代理类不让你访问目标，例如商家不让用户访问厂家</p><h1 id="4-实现代理的方式"><a href="#4-实现代理的方式" class="headerlink" title="4 实现代理的方式"></a>4 实现代理的方式</h1><h2 id="4-1-静态代理"><a href="#4-1-静态代理" class="headerlink" title="4.1 静态代理"></a>4.1 静态代理</h2><h3 id="4-1-1-什么是静态代理？"><a href="#4-1-1-什么是静态代理？" class="headerlink" title="4.1.1 什么是静态代理？"></a>4.1.1 什么是静态代理？</h3><p>（1）代理类是自己手工实现的，自己创建一个Java类，表示代理类。</p><p>（2）同时你所要代理的目标是确定的。</p><h3 id="4-1-2-静态代理的特点："><a href="#4-1-2-静态代理的特点：" class="headerlink" title="4.1.2 静态代理的特点："></a>4.1.2 静态代理的特点：</h3><p>（1）实现简单</p><p>（2）容易理解</p><h3 id="4-1-3-静态代理的缺点："><a href="#4-1-3-静态代理的缺点：" class="headerlink" title="4.1.3 静态代理的缺点："></a>4.1.3 静态代理的缺点：</h3><p>当项目中目标类和代理类很多的时候，会有以下的特点：</p><p>（1）当目标类增加了，代理类可能也需要成倍的增加，代理类数量过多。</p><p>（2）当你的接口中功能增加了，或者修改了，会影响众多的实现类，厂家类，代理都需要修改，影响比较多。</p><h3 id="4-1-4-静态代理举例："><a href="#4-1-4-静态代理举例：" class="headerlink" title="4.1.4 静态代理举例："></a>4.1.4 静态代理举例：</h3><p>模拟一个用户购买U盘的行为</p><pre><code>    用户：客户端类    商家：代理，代理某个品牌的U盘    厂家：目标类    三者的关系：用户（客户端）  ----  商家（代理）----厂家（目标）    商家和厂家都是卖U盘的，他们完成的功能是一致的，都是卖U盘。</code></pre><p>实现步骤：<br>（1）创建一个接口，定义卖U盘的方法，表示你的厂家和商家做的事情。</p><p>（2）创建厂家类，实现（1）步骤的接口</p><p>（3）创建商家，就是代理，也需要实现（1）步骤中的接口</p><p>（4）创建客户端类，调用商家的方法买一个U盘</p><p>代理类完成的功能：<br>（1）实现目标类中方法的调用</p><p>（2）功能增强</p><p>Java代码实现如下：<br>（1）创建一个接口，定义卖U盘的方法，表示你的厂家和商家做的事情。</p><pre class=" language-Java"><code class="language-Java">package com.powernode.service; /** * 表示功能的，厂家，商家都要完成的功能 * 备注：下面只是定义了一个卖U盘的功能，也可以写其它的功能 */public interface UsbSell &#123;     //定义方法 参数 amount：表示一次购买的数量，暂时不用    //返回一个U盘的价格     float sell(int amout);     &#125;</code></pre><p>（2）创建厂家类，实现（1）步骤的接口</p><pre class=" language-Java"><code class="language-Java">package com.powernode.factory; import com.powernode.service.UsbSell; //目标类：金士顿厂家.不接受用户的单独购买public class UsbKingFactory implements UsbSell &#123;    @Override    public float sell(int amout) &#123;        //一个128G的U盘是85元        return 85.0f;    &#125;&#125;</code></pre><p>（3）创建商家，就是代理，也需要实现（1）步骤中的接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>shangjia<span class="token punctuation">;</span> <span class="token keyword">import</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>UsbKingFactory<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UsbSell<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/** * 淘宝是一个商家，代理金士顿厂家U盘的销售 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaoBao</span> <span class="token keyword">implements</span> <span class="token class-name">UsbSell</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> UsbKingFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsbKingFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//实现销售U盘功能</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token keyword">int</span> amout<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//向厂家发送订单，告诉厂家，我买了U盘，厂家发货</span>        <span class="token keyword">float</span> price <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span>amout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//厂家的价格</span>         <span class="token comment" spellcheck="true">//商家需要加价，也就是代理需要增加价格</span>        <span class="token comment" spellcheck="true">//增强功能，代理类在完成目标类方法调用后，增强的功能。在目标类的方法调用后，你做的其它功能，都是增强的意思。</span>        price <span class="token operator">=</span> price <span class="token operator">+</span> <span class="token number">25</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回增加的价格</span>        <span class="token keyword">return</span> price<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>（4）创建客户端类，调用商家的方法买一个U盘</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">;</span> <span class="token keyword">import</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>shangjia<span class="token punctuation">.</span>TaoBao<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShopMain</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         TaoBao taoBao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaoBao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> price <span class="token operator">=</span> taoBao<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过淘宝的商家，购买得u盘单价"</span> <span class="token operator">+</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="4-2-动态代理"><a href="#4-2-动态代理" class="headerlink" title="4.2 动态代理"></a>4.2 动态代理</h2><p>在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。</p><p>1）代理类数量可以很少</p><p>2）当你修改了接口中的方法时，不会影响代理类</p><h3 id="4-2-1-什么是动态代理"><a href="#4-2-1-什么是动态代理" class="headerlink" title="4.2.1 什么是动态代理"></a>4.2.1 什么是动态代理</h3><p>说起动态代理，就先说下什么是动态：</p><p>动态指的是在程序执行时，调用jdk提供的方法才能创建代理类的对象。</p><p>动态代理是：</p><p>在程序执行过程中，使用jdk的反射机制，创建代理类对象，并动态的指定要代理目标类（静态代理中，代理目标是固定，写死的）。而不用你创建类文件，不用写Java文件。</p><p>动态代理其实就是jdk运行期间，动态创建class字节码并加载到JVM</p><p>换句话说，动态代理是一种创建Java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。一般创建对象是 new Xx()，那现在动态代理也可以做这个事情。</p><p>动态代理的实现方式常用的有两种：</p><p><strong>1、JDK动态代理</strong></p><p>使用Java反射包中的类和接口实现动态代理的功能。</p><p>1）反射，Method类，表示方法。类中的方法，通过Method可以执行某个方法。</p><p>2）jdk动态代理的实现</p><p>反射包 java.lang.reflect, 里面有三个类：InvocationHandler, Method, Proxy。</p><p>（1）InvocationHandler 接口（中文意思：调用处理器）：就是一个方法 invoke（）</p><p>invoke（）:表示代理对象要执行的功能代码，你的代理类要完成的功能就卸载invoke（）方法中。</p><pre><code>    代理类完成的功能：            1、调用目标方法，执行目标方法的功能            2、功能增强，在目标方法调用时，增加功能。</code></pre><p>invoke（）方法原型：</p><pre class=" language-Java"><code class="language-Java">public Object invoke(Object proxy, Method method, Object[] args)</code></pre><p>入参介绍：</p><p>Object proxy：jdk创建的代理对象，无需赋值<br>Method method: 目标类中的方法，jdk提供method对象的<br>object[] args: 目标类中方法的参数<br>InvocationHandler 接口 ： 表示你的代理要干什么。</p><p>怎么使用：</p><pre class=" language-Java"><code class="language-Java">    1）创建类实现接口InvocationHandler    2）重写invoke（）方法，把原来静态代理中代理类要完成的功能，写到这个地方</code></pre><p>（2）Method类：目标类中的方法。</p><p>作用：通过Method可以执行某个目标类的方法，Method.invoke（）；</p><pre class=" language-Java"><code class="language-Java">    Method.invoke(目标对象， 方法的参数)</code></pre><p>说明：Method.invoke（）就是用来执行目标方法的，等同于上面在静态代理中的</p><pre class=" language-Java"><code class="language-Java"> float price = factory.sell(amout);//厂家的价格</code></pre><p>（3）Proxy类：核心的对象，创建代理对象，之前创建对象都是new 类的构造方法（）现在我们使用Proxy类的方法，代理new的使用。</p><p>方法： 静态方法：newProxyInstance（）</p><p>作用：创建代理对象，等同于我上述静态代理举例中的new TaoBao（）&#x3D; new TaoBao（）</p><p>方法原型：</p><pre class=" language-Java"><code class="language-Java">public static Object newProxyInstance(ClassLoader loader,                                      Class<?>[] interfaces,                                      InvocationHandler h)</code></pre><p>入参介绍：</p><p>ClassLoader loader ：类加载器，负责向内存中加载对象的，使用反射获取对象的classLoader。 例如： 类A： A.getClass.getClassLoader(), 主要是为了获取目标对象的类加载器。<br>Class&lt;?&gt;[] interfaces：接口，目标对象实现的接口，也是反射获取的。<br>InvocationHandler h：是我们自己写的，代理类要完成的功能。<br>出参介绍：</p><p>Object：就是目标对象的代理对象</p><h3 id="4-2-2-动态代理举例"><a href="#4-2-2-动态代理举例" class="headerlink" title="4.2.2 动态代理举例"></a>4.2.2 动态代理举例</h3><p>实现动态代理的步骤：<br>（1）创建接口，定义目标类要完成的功能</p><p>（2）创建目标类实现接口</p><p>（3）创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能</p><p>​1）调用目标方法</p><p>​2）增强功能</p><p>（4）使用Proxy类的静态方法，创建代理对象。并把返回值转为接口类型</p><p>Java代码实现如下<br>（1）创建接口，定义目标类要完成的功能</p><pre class=" language-Java"><code class="language-Java">package com.powernode.service; /** * 表示功能的，厂家，商家都要完成的功能 * 备注：下面只是定义了一个卖U盘的功能，也可以写其它的功能 */public interface UsbSell &#123;     //定义方法 参数 amount：表示一次购买的数量，暂时不用    //返回一个U盘的价格     float sell(int amout); &#125;</code></pre><p>（2）创建目标类实现接口</p><pre class=" language-Java"><code class="language-Java">package com.powernode.factory; import com.powernode.service.UsbSell; //目标类：金士顿厂家.不接受用户的单独购买public class UsbKingFactory implements UsbSell &#123;    @Override    public float sell(int amout) &#123;        //一个128G的U盘是85元        return 85.0f;    &#125;&#125;</code></pre><p>（3）创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能</p><pre class=" language-Java"><code class="language-Java">package com.powernode.handler;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method; /** * 必须实现InvocationHandler接口，完成代理类要做的功能（1.调用目标方法 2.功能增强） */public class MysellHandler implements InvocationHandler &#123;        private Object  target = null;    //动态代理：目标对象是活动的，不是固定的，需要传入进来。    //传入是谁，就给谁创建代理    public MysellHandler(Object target)&#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;       // float price = factory.sell(amout);//厂家的价格         //商家需要加价，也就是代理需要增加价格        //增强功能，代理类在完成目标类方法调用后，增强的功能。在目标类的方法调用后，你做的其它功能，都是增强的意思。        //price = price + 25;        //返回增加的价格         //(1)执行目标方法        Object res = null;        method.invoke(target, args);//执行目标方法，target你传入的是A，那你的目标方法就是A，你传入的是B，那目标方法就是B        //(2)进行功能增强        if (res != null) &#123;            Float price = (Float) res;            price = price+25;            res = price;        &#125;        return res;    &#125;&#125;</code></pre><p>（4）使用Proxy类的静态方法，创建代理对象。并把返回值转为接口类型</p><pre class=" language-Java"><code class="language-Java">package com.powernode; import com.powernode.factory.UsbKingFactory;import com.powernode.handler.MysellHandler;import com.powernode.service.UsbSell;import com.powernode.shangjia.TaoBao; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy; public class ShopMain &#123;     public static void main(String[] args) &#123;        //创建代理对象，使用Proxy        // 1、创建目标对象       // UsbKingFactory factory = new UsbKingFactory();        UsbSell factory = new UsbKingFactory();         //2、创建InvocationHandler对象        InvocationHandler handler = new MysellHandler(factory);         //3、创建代理对象        UsbSell proxy = (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(),                factory.getClass().getInterfaces(),                handler);         //4、通过代理执行方法        float price = proxy.sell(1);        System.out.println(price);     &#125;&#125;</code></pre><p><strong>2、通过CGLIB动态代理</strong></p><p>cglib是第三方的工具库，创建代理对象。它可以在运行期间扩展Java类与实现Java接口，它广泛的被许多AOP的框架使用，例如Spring AOP。</p><p>使用JDK的Proxy实现代理，要求目标类和代理类实现相同的接口。若目标类不存在接口，则无法使用该方式实现。</p><p>但对于无接口的类，要为其创建动态代理，就要通过cglib来实现。cglib代理的生成原理是生成目标类的子类，而子类是通过增强过的，这个子类对象就是代理对象，所以，使用cglib生成动态代理，要求目标类必须能够被继承，即不能是final的类。</p><p>cglib在很多的框架中使用。比如mybatis，spring框架中都有使用。</p><p>在Java中，要想创建对象：</p><p>（1）创建类文件，Java文件编译为class</p><p>（2）使用构造方法，创建类的对象</p><p>然而，动态代理是不用做上面的步骤（1）只需要经过步骤（2）就可以把对象创建出来</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2023/07/31/hello-hexo/"/>
      <url>/2023/07/31/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
