<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql慢查询的排查及优化</title>
      <link href="/2023/08/05/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%8E%92%E6%9F%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2023/08/05/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%8E%92%E6%9F%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一、第一步-开启mysql慢查询"><a href="#一、第一步-开启mysql慢查询" class="headerlink" title="一、第一步.开启mysql慢查询"></a>一、第一步.开启mysql慢查询</h1><p>方式一：修改配置文件  在 my.ini 增加几行:  主要是慢查询的定义时间(超过2秒就是慢查询)，以及慢查询log日志记录( slow_query_log)</p><p>方法二：通过MySQL数据库开启慢查询:</p><h1 id="二、分析慢查询日志"><a href="#二、分析慢查询日志" class="headerlink" title="二、分析慢查询日志"></a>二、分析慢查询日志</h1><p>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句</p><p>例如：执行EXPLAIN SELECT * FROM tb_device ORDER BY start_time LIMIT 0,1000</p><p>得到如下结果： 显示结果分析：</p><pre class=" language-mysql"><code class="language-mysql">table |  type | possible_keys | key |key_len  | ref | rows | Extra  </code></pre><p>EXPLAIN列的解释：</p><p><strong>table</strong>: 显示这一行的数据是关于哪张表的</p><p><strong>type</strong>: 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、<strong>indexhe</strong>和ALL</p><p><strong>rows</strong>: 显示需要扫描行数</p><p><strong>key</strong>: 使用的索引</p><h1 id="三、常见的慢查询优化"><a href="#三、常见的慢查询优化" class="headerlink" title="三、常见的慢查询优化"></a>三、常见的慢查询优化</h1><h2 id="1、索引没起作用的情况"><a href="#1、索引没起作用的情况" class="headerlink" title="1、索引没起作用的情况"></a>1、索引没起作用的情况</h2><ol><li>使用LIKE关键字的查询语句</li></ol><p>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</p><ol start="2"><li>使用多列索引的查询语句</li></ol><p>MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</p><h2 id="2、优化数据库结构"><a href="#2、优化数据库结构" class="headerlink" title="2、优化数据库结构"></a>2、优化数据库结构</h2><p>合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><ol><li>将字段很多的表分解成多个表</li></ol><p>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><ol start="2"><li>增加中间表</li></ol><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</p><h2 id="3、分解关联查询"><a href="#3、分解关联查询" class="headerlink" title="3、分解关联查询"></a>3、分解关联查询</h2><p>将一个大的查询分解为多个小查询是很有必要的。</p><p>很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM tagJOIN tag_post ON tag_id = tag.idJOIN post ON tag_post.post_id = post.idWHERE tag.tag = 'mysql';</code></pre><p>分解为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag <span class="token keyword">WHERE</span> tag <span class="token operator">=</span> <span class="token string">'mysql'</span><span class="token punctuation">;</span>   <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tag_post <span class="token keyword">WHERE</span> tag_id <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> post <span class="token keyword">WHERE</span> post<span class="token punctuation">.</span>id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token number">456</span><span class="token punctuation">,</span><span class="token number">567</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="4、优化LIMIT分页"><a href="#4、优化LIMIT分页" class="headerlink" title="4、优化LIMIT分页"></a>4、优化LIMIT分页</h2><p>在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p><p>一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p><p>优化此类查询的一个最简单的方法是：<strong>尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</strong></p><p>对于下面的查询：</p><pre class=" language-mysql"><code class="language-mysql">select id,title from collect limit 90000,10;</code></pre><p>该语句存在的最大问题在于limit M,N中偏移量M太大(我们暂不考虑筛选字段上要不要添加索引的影响)，导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。</p><p>如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。 试想，如果我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的10条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次 查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到10条满足条件的记录了。</p><p><strong>方法一：在筛选字段(title)上加索引</strong></p><p>title字段加索引  (此效率如何未加验证)</p><p><strong>方法二：先查询出主键id值</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span>title <span class="token keyword">from</span> collect <span class="token keyword">where</span> id<span class="token operator">>=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> collect <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</p><p><strong>方法三：“关延迟联”</strong></p><p>如果这个表非常大，那么这个查询可以改写成如下的方式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">Select</span> news<span class="token punctuation">.</span>id<span class="token punctuation">,</span> news<span class="token punctuation">.</span>description <span class="token keyword">from</span> news <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> news <span class="token keyword">order</span> <span class="token keyword">by</span> title <span class="token keyword">limit</span> <span class="token number">50000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myNew <span class="token keyword">using</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里的“关延迟联”将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p><p><strong>方法四：建立复合索引 acct_id和create_time</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> acct_trans_log <span class="token keyword">WHERE</span>  acct_id <span class="token operator">=</span> <span class="token number">3095</span>  <span class="token keyword">order</span> <span class="token keyword">by</span> create_time <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态代理和动态代理详解</title>
      <link href="/2023/08/04/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/08/04/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代理"><a href="#1-代理" class="headerlink" title="1 代理"></a>1 代理</h1><ul><li>生活中的代理：比如我们生活中比较熟悉的代购、中介、商家等都是属于代理</li></ul><h1 id="2-什么是代理模式"><a href="#2-什么是代理模式" class="headerlink" title="2 什么是代理模式"></a>2 什么是代理模式</h1><p>代理模式是指：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。换句话说，使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑。</p><p>客户类真正想要访问的对象是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。</p><p>比如：有A、B、C三个类，A原来可以调用C类的方法，现在因为某种原因C类不允许A类调用其方法，但B类可以调用C类的方法。A类通过B类调用C类的方法。这里B是C的代理。</p><h1 id="3-代理模式的作用"><a href="#3-代理模式的作用" class="headerlink" title="3 代理模式的作用"></a>3 代理模式的作用</h1><p>功能增强: 在原有的功能上，增加了额外的功能，新增加的功能，叫做功能增强，</p><p>控制访问：代理类不让你访问目标，例如商家不让用户访问厂家</p><h1 id="4-实现代理的方式"><a href="#4-实现代理的方式" class="headerlink" title="4 实现代理的方式"></a>4 实现代理的方式</h1><h2 id="4-1-静态代理"><a href="#4-1-静态代理" class="headerlink" title="4.1 静态代理"></a>4.1 静态代理</h2><h3 id="4-1-1-什么是静态代理？"><a href="#4-1-1-什么是静态代理？" class="headerlink" title="4.1.1 什么是静态代理？"></a>4.1.1 什么是静态代理？</h3><p>（1）代理类是自己手工实现的，自己创建一个Java类，表示代理类。</p><p>（2）同时你所要代理的目标是确定的。</p><h3 id="4-1-2-静态代理的特点："><a href="#4-1-2-静态代理的特点：" class="headerlink" title="4.1.2 静态代理的特点："></a>4.1.2 静态代理的特点：</h3><p>（1）实现简单</p><p>（2）容易理解</p><h3 id="4-1-3-静态代理的缺点："><a href="#4-1-3-静态代理的缺点：" class="headerlink" title="4.1.3 静态代理的缺点："></a>4.1.3 静态代理的缺点：</h3><p>当项目中目标类和代理类很多的时候，会有以下的特点：</p><p>（1）当目标类增加了，代理类可能也需要成倍的增加，代理类数量过多。</p><p>（2）当你的接口中功能增加了，或者修改了，会影响众多的实现类，厂家类，代理都需要修改，影响比较多。</p><h3 id="4-1-4-静态代理举例："><a href="#4-1-4-静态代理举例：" class="headerlink" title="4.1.4 静态代理举例："></a>4.1.4 静态代理举例：</h3><p>模拟一个用户购买U盘的行为</p><pre><code>    用户：客户端类    商家：代理，代理某个品牌的U盘    厂家：目标类    三者的关系：用户（客户端）  ----  商家（代理）----厂家（目标）    商家和厂家都是卖U盘的，他们完成的功能是一致的，都是卖U盘。</code></pre><p>实现步骤：<br>（1）创建一个接口，定义卖U盘的方法，表示你的厂家和商家做的事情。</p><p>（2）创建厂家类，实现（1）步骤的接口</p><p>（3）创建商家，就是代理，也需要实现（1）步骤中的接口</p><p>（4）创建客户端类，调用商家的方法买一个U盘</p><p>代理类完成的功能：<br>（1）实现目标类中方法的调用</p><p>（2）功能增强</p><p>Java代码实现如下：<br>（1）创建一个接口，定义卖U盘的方法，表示你的厂家和商家做的事情。</p><pre class=" language-Java"><code class="language-Java">package com.powernode.service; /** * 表示功能的，厂家，商家都要完成的功能 * 备注：下面只是定义了一个卖U盘的功能，也可以写其它的功能 */public interface UsbSell &#123;     //定义方法 参数 amount：表示一次购买的数量，暂时不用    //返回一个U盘的价格     float sell(int amout);     &#125;</code></pre><p>（2）创建厂家类，实现（1）步骤的接口</p><pre class=" language-Java"><code class="language-Java">package com.powernode.factory; import com.powernode.service.UsbSell; //目标类：金士顿厂家.不接受用户的单独购买public class UsbKingFactory implements UsbSell &#123;    @Override    public float sell(int amout) &#123;        //一个128G的U盘是85元        return 85.0f;    &#125;&#125;</code></pre><p>（3）创建商家，就是代理，也需要实现（1）步骤中的接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>shangjia<span class="token punctuation">;</span> <span class="token keyword">import</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>UsbKingFactory<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UsbSell<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/** * 淘宝是一个商家，代理金士顿厂家U盘的销售 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaoBao</span> <span class="token keyword">implements</span> <span class="token class-name">UsbSell</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> UsbKingFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsbKingFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">//实现销售U盘功能</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token keyword">int</span> amout<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//向厂家发送订单，告诉厂家，我买了U盘，厂家发货</span>        <span class="token keyword">float</span> price <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span>amout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//厂家的价格</span>         <span class="token comment" spellcheck="true">//商家需要加价，也就是代理需要增加价格</span>        <span class="token comment" spellcheck="true">//增强功能，代理类在完成目标类方法调用后，增强的功能。在目标类的方法调用后，你做的其它功能，都是增强的意思。</span>        price <span class="token operator">=</span> price <span class="token operator">+</span> <span class="token number">25</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回增加的价格</span>        <span class="token keyword">return</span> price<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>（4）创建客户端类，调用商家的方法买一个U盘</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">;</span> <span class="token keyword">import</span> com<span class="token punctuation">.</span>powernode<span class="token punctuation">.</span>shangjia<span class="token punctuation">.</span>TaoBao<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShopMain</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         TaoBao taoBao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaoBao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> price <span class="token operator">=</span> taoBao<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过淘宝的商家，购买得u盘单价"</span> <span class="token operator">+</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="4-2-动态代理"><a href="#4-2-动态代理" class="headerlink" title="4.2 动态代理"></a>4.2 动态代理</h2><p>在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。</p><p>1）代理类数量可以很少</p><p>2）当你修改了接口中的方法时，不会影响代理类</p><h3 id="4-2-1-什么是动态代理"><a href="#4-2-1-什么是动态代理" class="headerlink" title="4.2.1 什么是动态代理"></a>4.2.1 什么是动态代理</h3><p>说起动态代理，就先说下什么是动态：</p><p>动态指的是在程序执行时，调用jdk提供的方法才能创建代理类的对象。</p><p>动态代理是：</p><p>在程序执行过程中，使用jdk的反射机制，创建代理类对象，并动态的指定要代理目标类（静态代理中，代理目标是固定，写死的）。而不用你创建类文件，不用写Java文件。</p><p>动态代理其实就是jdk运行期间，动态创建class字节码并加载到JVM</p><p>换句话说，动态代理是一种创建Java对象的能力，让你不用创建TaoBao类，就能创建代理类对象。一般创建对象是 new Xx()，那现在动态代理也可以做这个事情。</p><p>动态代理的实现方式常用的有两种：</p><p><strong>1、JDK动态代理</strong></p><p>使用Java反射包中的类和接口实现动态代理的功能。</p><p>1）反射，Method类，表示方法。类中的方法，通过Method可以执行某个方法。</p><p>2）jdk动态代理的实现</p><p>反射包 java.lang.reflect, 里面有三个类：InvocationHandler, Method, Proxy。</p><p>（1）InvocationHandler 接口（中文意思：调用处理器）：就是一个方法 invoke（）</p><p>invoke（）:表示代理对象要执行的功能代码，你的代理类要完成的功能就卸载invoke（）方法中。</p><pre><code>    代理类完成的功能：            1、调用目标方法，执行目标方法的功能            2、功能增强，在目标方法调用时，增加功能。</code></pre><p>invoke（）方法原型：</p><pre class=" language-Java"><code class="language-Java">public Object invoke(Object proxy, Method method, Object[] args)</code></pre><p>入参介绍：</p><p>Object proxy：jdk创建的代理对象，无需赋值<br>Method method: 目标类中的方法，jdk提供method对象的<br>object[] args: 目标类中方法的参数<br>InvocationHandler 接口 ： 表示你的代理要干什么。</p><p>怎么使用：</p><pre class=" language-Java"><code class="language-Java">    1）创建类实现接口InvocationHandler    2）重写invoke（）方法，把原来静态代理中代理类要完成的功能，写到这个地方</code></pre><p>（2）Method类：目标类中的方法。</p><p>作用：通过Method可以执行某个目标类的方法，Method.invoke（）；</p><pre class=" language-Java"><code class="language-Java">    Method.invoke(目标对象， 方法的参数)</code></pre><p>说明：Method.invoke（）就是用来执行目标方法的，等同于上面在静态代理中的</p><pre class=" language-Java"><code class="language-Java"> float price = factory.sell(amout);//厂家的价格</code></pre><p>（3）Proxy类：核心的对象，创建代理对象，之前创建对象都是new 类的构造方法（）现在我们使用Proxy类的方法，代理new的使用。</p><p>方法： 静态方法：newProxyInstance（）</p><p>作用：创建代理对象，等同于我上述静态代理举例中的new TaoBao（）&#x3D; new TaoBao（）</p><p>方法原型：</p><pre class=" language-Java"><code class="language-Java">public static Object newProxyInstance(ClassLoader loader,                                      Class<?>[] interfaces,                                      InvocationHandler h)</code></pre><p>入参介绍：</p><p>ClassLoader loader ：类加载器，负责向内存中加载对象的，使用反射获取对象的classLoader。 例如： 类A： A.getClass.getClassLoader(), 主要是为了获取目标对象的类加载器。<br>Class&lt;?&gt;[] interfaces：接口，目标对象实现的接口，也是反射获取的。<br>InvocationHandler h：是我们自己写的，代理类要完成的功能。<br>出参介绍：</p><p>Object：就是目标对象的代理对象</p><h3 id="4-2-2-动态代理举例"><a href="#4-2-2-动态代理举例" class="headerlink" title="4.2.2 动态代理举例"></a>4.2.2 动态代理举例</h3><p>实现动态代理的步骤：<br>（1）创建接口，定义目标类要完成的功能</p><p>（2）创建目标类实现接口</p><p>（3）创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能</p><p>​1）调用目标方法</p><p>​2）增强功能</p><p>（4）使用Proxy类的静态方法，创建代理对象。并把返回值转为接口类型</p><p>Java代码实现如下<br>（1）创建接口，定义目标类要完成的功能</p><pre class=" language-Java"><code class="language-Java">package com.powernode.service; /** * 表示功能的，厂家，商家都要完成的功能 * 备注：下面只是定义了一个卖U盘的功能，也可以写其它的功能 */public interface UsbSell &#123;     //定义方法 参数 amount：表示一次购买的数量，暂时不用    //返回一个U盘的价格     float sell(int amout); &#125;</code></pre><p>（2）创建目标类实现接口</p><pre class=" language-Java"><code class="language-Java">package com.powernode.factory; import com.powernode.service.UsbSell; //目标类：金士顿厂家.不接受用户的单独购买public class UsbKingFactory implements UsbSell &#123;    @Override    public float sell(int amout) &#123;        //一个128G的U盘是85元        return 85.0f;    &#125;&#125;</code></pre><p>（3）创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能</p><pre class=" language-Java"><code class="language-Java">package com.powernode.handler;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method; /** * 必须实现InvocationHandler接口，完成代理类要做的功能（1.调用目标方法 2.功能增强） */public class MysellHandler implements InvocationHandler &#123;        private Object  target = null;    //动态代理：目标对象是活动的，不是固定的，需要传入进来。    //传入是谁，就给谁创建代理    public MysellHandler(Object target)&#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;       // float price = factory.sell(amout);//厂家的价格         //商家需要加价，也就是代理需要增加价格        //增强功能，代理类在完成目标类方法调用后，增强的功能。在目标类的方法调用后，你做的其它功能，都是增强的意思。        //price = price + 25;        //返回增加的价格         //(1)执行目标方法        Object res = null;        method.invoke(target, args);//执行目标方法，target你传入的是A，那你的目标方法就是A，你传入的是B，那目标方法就是B        //(2)进行功能增强        if (res != null) &#123;            Float price = (Float) res;            price = price+25;            res = price;        &#125;        return res;    &#125;&#125;</code></pre><p>（4）使用Proxy类的静态方法，创建代理对象。并把返回值转为接口类型</p><pre class=" language-Java"><code class="language-Java">package com.powernode; import com.powernode.factory.UsbKingFactory;import com.powernode.handler.MysellHandler;import com.powernode.service.UsbSell;import com.powernode.shangjia.TaoBao; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy; public class ShopMain &#123;     public static void main(String[] args) &#123;        //创建代理对象，使用Proxy        // 1、创建目标对象       // UsbKingFactory factory = new UsbKingFactory();        UsbSell factory = new UsbKingFactory();         //2、创建InvocationHandler对象        InvocationHandler handler = new MysellHandler(factory);         //3、创建代理对象        UsbSell proxy = (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(),                factory.getClass().getInterfaces(),                handler);         //4、通过代理执行方法        float price = proxy.sell(1);        System.out.println(price);     &#125;&#125;</code></pre><p><strong>2、通过CGLIB动态代理</strong></p><p>cglib是第三方的工具库，创建代理对象。它可以在运行期间扩展Java类与实现Java接口，它广泛的被许多AOP的框架使用，例如Spring AOP。</p><p>使用JDK的Proxy实现代理，要求目标类和代理类实现相同的接口。若目标类不存在接口，则无法使用该方式实现。</p><p>但对于无接口的类，要为其创建动态代理，就要通过cglib来实现。cglib代理的生成原理是生成目标类的子类，而子类是通过增强过的，这个子类对象就是代理对象，所以，使用cglib生成动态代理，要求目标类必须能够被继承，即不能是final的类。</p><p>cglib在很多的框架中使用。比如mybatis，spring框架中都有使用。</p><p>在Java中，要想创建对象：</p><p>（1）创建类文件，Java文件编译为class</p><p>（2）使用构造方法，创建类的对象</p><p>然而，动态代理是不用做上面的步骤（1）只需要经过步骤（2）就可以把对象创建出来</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2023/07/31/hello-hexo/"/>
      <url>/2023/07/31/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
